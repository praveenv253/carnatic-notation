#!/usr/bin/env python3

"""
Python script to create the notation.sty latex package.
"""

from __future__ import print_function, division
import itertools
import yaml

TALAM_CONFIG_FILE = 'talam-config.yml'
DEFAULT_OUTPUT_FILE = 'notat.sty'


def load_talam_configs(talam_names):
    with open(TALAM_CONFIG_FILE) as f:
        config = yaml.load(f.read())
    try:
        talam_configs dict((name, config[name]) for name in talam_names)
    except KeyError:
        return None

    return talam_configs


def parse_config(talam_config):
    # NOTE: Function definition is incomplete...
    # Need to check what remains to be done
    pattern = talam_config['pattern']
    jathi = int(talam_config['jathi'])
    nadai = int(talam_config['nadai'])
    kalai = int(talam_config['kalai'])

    num_beats = (pattern.count('l') * jathi + pattern.count('d') * 2
                 + pattern.count('a')) * kalai
    num_aksharas = num_beats * nadai

    # TODO: Not taking care of newlines currently
    spec = ''
    spec_list = pattern.split(' ')
    for j, i in enumerate(spec_list):
        if i == 'l':
            spec += ('X ' * nadai + 'A ') * jathi * kalai
            try:
                if spec_list[j+1] == 'd':
                    spec += 'B'
            except IndexError:
                pass
        elif i == 'd':
            spec += ('X ' * nadai + 'A ') * 2 * kalai + 'B '
        elif i == 'a':
            spec += ('X ' * nadai + 'A ') * kalai + 'B '

    return spec


def render_talam(talam_configs, package=False):
    # NOTE: Function definition is incomplete...
    # Need to check what remains to be done
    header = ''
    if package: header = """
    % Autogenerated by notation_compiler.py. Do not edit!
    % vim: set filetype=tex :

    % Notation package, for notating carnatic music
    \NeedsTeXFormat{LaTeX2e}
    \ProvidesPackage{notation}[2018/01/05 LaTeX package for notating Carnatic Music]

    \RequirePackage{tabularx}

    """

    # Need to make spaces in definitions configurable
    definitions = '\\newcolumntype{A}{>{\\hspace{3mm}}l<{\\hspace{3mm}}}\n'
    definitions += '\\newcolumntype{B}{>{\\hspace{0mm}}l<{\\hspace{0mm}}}\n'

    talam_text = ''
    for talam_name, talam_config in talam_config.items():
        newenv = r'\newenvironment{' + talam_name.title() + 'Talam}'
        # TODO: Fix the column spec based on the talam config
        col_spec = parse_config(talam_config)
        before = '{\n\t\\begin{tabularx}{\\textwidth}{*{}{K}}\n}'
        after = '{\n\t\\end{tabularx}\n}'
        talam_text += '\n'.join((newenv, before, after)) + '\n'

    footer = '\\endinput' if package else ''

    return '\n'.join((header, definitions, talam_text, footer))


if __name__ == '__main__':
    talam_names = ['triputa',]
    talam_configs = load_talam_configs(talam_names)
    # TODO: Provide a way to update the talam config dict with custom options
    # while loading
    if talam_configs is None:
        raise ValueError('Invalid talam name, or default configuration absent')
    render_string = render_talams(talam_configs, package=True)
    with open(DEFAULT_OUTPUT_FILE, 'w') as outfile:
        print(render_string, file=outfile)
